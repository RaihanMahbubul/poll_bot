import telegram
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes,
)
from telegram.ext._jobqueue import Job
from telegram.constants import ParseMode # <-- рж╣рзЗрж▓рзНржк/рж╕рзНржЯрж╛рж░рзНржЯ ржлрж░ржорзНржпрж╛ржЯрж┐ржВ ржПрж░ ржЬржирзНржп
import google.generativeai as genai
import json
import asyncio
import os
import psycopg2
from urllib.parse import urlparse
from flask import Flask
import threading

# -----------------------------------------------------------------
# --- ржЯрзЛржХрзЗржи ржмрж╛ ржХрзА ржПржЦрж╛ржирзЗ рж▓рзЛржб ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ ржирж╛ ---
# --- ржПржЧрзБрж▓рзЛ ржПржЦржи main() ржлрж╛ржВрж╢ржирзЗрж░ ржнрзЗрждрж░рзЗ рж▓рзЛржб рж╣ржмрзЗ ---
# -----------------------------------------------------------------

# conversation-ржПрж░ ржжрзБржЯрж┐ ржЕржмрж╕рзНржерж╛ (state)
STATE_IDLE, STATE_AWAITING_INTRO = range(2)
TEXT_BUFFER_DELAY = 3  # рж╕рзЗржХрзЗржирзНржб

# --- Flask ржУрзЯрзЗржм рж╕рж╛рж░рзНржнрж╛рж░ рж╕рзЗржЯржЖржк (ржмржЯржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп) ---
app = Flask(__name__)
@app.route('/')
def home():
    """ржПржЯрж┐ UptimeRobot-ржХрзЗ ржжрзЗржЦрж╛ржмрзЗ ржпрзЗ ржмржЯржЯрж┐ рж╕ржЪрж▓ ржЖржЫрзЗред"""
    return "I am alive and polling!"

def run_web_server():
    """Flask рж╕рж╛рж░рзНржнрж╛рж░ржЯрж┐ ржЪрж╛рж▓рзБ ржХрж░рзЗред"""
    # Render рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯржнрж╛ржмрзЗ PORT ржПржиржнрж╛рзЯрж░ржиржорзЗржирзНржЯ ржнрзЗрж░рж┐рзЯрзЗржмрж▓ рж╕рзЗржЯ ржХрж░рзЗред
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)

# --- ржирждрзБржи ржлрж╛ржВрж╢ржи: ржбрж╛ржЯрж╛ржмрзЗрж╕ ржХрж╛ржирзЗржХрж╢ржи ---
def get_db_connection():
    """Render-ржПрж░ DATABASE_URL ржерзЗржХрзЗ ржХрж╛ржирзЗржХрж╢ржи рждрзИрж░рж┐ ржХрж░рзЗред"""
    try:
        # ржнрзЗрж░рж┐рзЯрзЗржмрж▓ржЯрж┐ ржПржЦрж╛ржирзЗ рж╕рж░рж╛рж╕рж░рж┐ ржкрзЬрж╛ рж╣ржЪрзНржЫрзЗ
        db_url = os.environ.get("DATABASE_URL")
        if not db_url:
            print("ржбрж╛ржЯрж╛ржмрзЗрж╕ ржХрж╛ржирзЗржХрж╢ржирзЗ рж╕ржорж╕рзНржпрж╛: DATABASE_URL ржЦрзБржБржЬрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
            return None
        conn = psycopg2.connect(db_url)
        return conn
    except Exception as e:
        print(f"ржбрж╛ржЯрж╛ржмрзЗрж╕ ржХрж╛ржирзЗржХрж╢ржирзЗ рж╕ржорж╕рзНржпрж╛: {e}")
        return None

# --- ржирждрзБржи ржлрж╛ржВрж╢ржи: ржбрж╛ржЯрж╛ржмрзЗрж╕ ржЯрзЗржмрж┐рж▓ рждрзИрж░рж┐ ---
def init_db():
    """ржмржЯ ржЪрж╛рж▓рзБ рж╣ржУрзЯрж╛рж░ рж╕ржорзЯ ржПржЗ ржлрж╛ржВрж╢ржи ржбрж╛ржЯрж╛ржмрзЗрж╕ ржЯрзЗржмрж┐рж▓ рждрзИрж░рж┐ ржХрж░ржмрзЗред"""
    conn = get_db_connection()
    if conn is None:
        print("ржбрж╛ржЯрж╛ржмрзЗрж╕ ржЗржирж┐рж╢рж┐рзЯрж╛рж▓рж╛ржЗржЬ ржХрж░рж╛ ржпрж╛ржЪрзНржЫрзЗ ржирж╛ред")
        return
        
    try:
        with conn.cursor() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS user_settings (
                    user_id BIGINT PRIMARY KEY,
                    target_channel TEXT
                );
            """)
            conn.commit()
        print("ржбрж╛ржЯрж╛ржмрзЗрж╕ ржЯрзЗржмрж┐рж▓ (user_settings) рж╕ржлрж▓ржнрж╛ржмрзЗ ржЪрзЗржХ/рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред")
    except Exception as e:
        print(f"ржЯрзЗржмрж┐рж▓ рждрзИрж░рж┐рждрзЗ рж╕ржорж╕рзНржпрж╛: {e}")
    finally:
        if conn:
            conn.close()

# --- ржирждрзБржи ржлрж╛ржВрж╢ржи: ржбрж╛ржЯрж╛ржмрзЗрж╕ ржерзЗржХрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржкрзЬрж╛ ---
def get_target_channel_from_db(user_id: int) -> str | None:
    conn = get_db_connection()
    if conn is None: return None
    
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT target_channel FROM user_settings WHERE user_id = %s", (user_id,))
            result = cur.fetchone()
            if result:
                return result[0] # target_channel
            return None
    except Exception as e:
        print(f"ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржкрзЬрж╛рждрзЗ рж╕ржорж╕рзНржпрж╛: {e}")
        return None
    finally:
        if conn:
            conn.close()

# --- ржирждрзБржи ржлрж╛ржВрж╢рж▓: ржбрж╛ржЯрж╛ржмрзЗрж╕рзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ рж╕рзЗржн ржХрж░рж╛ ---
def save_target_channel_to_db(user_id: int, target_channel: str):
    conn = get_db_connection()
    if conn is None: return

    try:
        with conn.cursor() as cur:
            # ON CONFLICT... (UPSERT): ржпржжрж┐ ржЗржЙржЬрж╛рж░ ржЖржЗржбрж┐ ржЖржЧрзЗ ржерзЗржХрзЗржЗ ржерж╛ржХрзЗ, рждржмрзЗ ржЖржкржбрзЗржЯ ржХрж░рзЛ
            cur.execute("""
                INSERT INTO user_settings (user_id, target_channel)
                VALUES (%s, %s)
                ON CONFLICT (user_id) DO UPDATE SET target_channel = EXCLUDED.target_channel;
            """, (user_id, target_channel))
            conn.commit()
    except Exception as e:
        print(f"ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ рж╕рзЗржн ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛: {e}")
    finally:
        if conn:
            conn.close()

# --- AI ржжрж┐рзЯрзЗ ржкрзНрж░рж╢рзНржи ржЬрзЗржирж╛рж░рзЗржЯ ржХрж░рж╛рж░ ржлрж╛ржВрж╢ржи (ржбрж╛ржЗржирж╛ржорж┐ржХ рж╕рж╛ржлрж┐ржХрзНрж╕ рж╕рж╣) ---
def get_questions_from_ai(text, ai_model): 
    # ржкрзНрж░ржорзНржкржЯ ржЖржкржбрзЗржЯ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ "suffix" ржирж╛ржорзЗ ржирждрзБржи ржПржХржЯрж┐ ржлрж┐рж▓рзНржб ржпрзЛржЧ ржХрж░рж╛рж░ ржЬржирзНржп
    prompt = f"""
    рждрзБржорж┐ ржПржХржЬржи ржжржХрзНрж╖ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯред рждрзЛржорж╛рж░ ржХрж╛ржЬ рж╣рж▓рзЛ ржирж┐ржЪрзЗрж░ ржЯрзЗржХрзНрж╕ржЯ ржерзЗржХрзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржорж╛рж▓рзНржЯрж┐ржкрж▓ ржЪрзЯрзЗрж╕ ржкрзНрж░рж╢рзНржи (MCQ) ржмрзЗрж░ ржХрж░рж╛ред
    рждрзЛржорж╛рж░ ржЙрждрзНрждрж░ ржЕржмрж╢рзНржпржЗ ржПржХржЯрж┐ JSON рж▓рж┐рж╕рзНржЯ ржлрж░ржорзНржпрж╛ржЯрзЗ рж╣рждрзЗ рж╣ржмрзЗред ржкрзНрж░рждрж┐ржЯрж┐ ржЕржмржЬрзЗржХрзНржЯрзЗ рзлржЯрж┐ ржХрзА ржерж╛ржХржмрзЗ:
    1. "question": (рж╕рзНржЯрзНрж░рж┐ржВ) ржорзВрж▓ ржкрзНрж░рж╢рзНржиржЯрж┐ред (ржкрзНрж░рж╢рзНржи ржерзЗржХрзЗ [SOT] ржмрж╛ [MAT 23-24] ржПрж░ ржорждрзЛ ржЯрзНржпрж╛ржЧ ржмрж╛ржж ржжрж┐рзЯрзЗ рж╢рзБржзрзБ ржкрзНрж░рж╢рзНржиржЯрж┐ ржмрзЗрж░ ржХрж░ржмрзЗ)ред
    2. "options": (рж▓рж┐рж╕рзНржЯ) ржЕржкрж╢ржиржЧрзБрж▓рзЛрж░ рж▓рж┐рж╕рзНржЯ (рж╕рж░рзНржмрзЛржЪрзНржЪ рззрзжржЯрж┐)ред
    3. "correct_option_index": (рж╕ржВржЦрзНржпрж╛) рж╕ржарж┐ржХ ржЕржкрж╢ржирзЗрж░ ржЗржиржбрзЗржХрзНрж╕ (0 ржерзЗржХрзЗ рж╢рзБрж░рзБ)ред
    4. "explanation": (рж╕рзНржЯрзНрж░рж┐ржВ) рж╕ржарж┐ржХ ржЙрждрзНрждрж░рзЗрж░ ржПржХржЯрж┐ рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржмрзНржпрж╛ржЦрзНржпрж╛ред ржпржжрж┐ ржмрзНржпрж╛ржЦрзНржпрж╛ ржЦрзБржБржЬрзЗ ржирж╛ ржкрж╛ржУ, рждржмрзЗ ржПрж░ ржорж╛ржи `null` ржжрж╛ржУред
    5. "suffix": (рж╕рзНржЯрзНрж░рж┐ржВ) ржкрзНрж░рж╢рзНржирзЗрж░ рж▓рж╛ржЗржирзЗрж░ рж╢рзЗрж╖рзЗ ржпржжрж┐ [ржмрзНрж░рзНржпрж╛ржХрзЗржЯрзЗрж░ ржоржзрзНржпрзЗ] ржХрзЛржирзЛ ржЯрзНржпрж╛ржЧ (ржпрзЗржоржи [MAT 23-24] ржмрж╛ [PHY-22]) ржерж╛ржХрзЗ, рждржмрзЗ рж╕рзЗржЯрж┐ ржПржЦрж╛ржирзЗ рж╣рзБржмрж╣рзБ ржпрзБржХрзНржд ржХрж░рзЛред ржпржжрж┐ ржПржоржи ржХрзЛржирзЛ ржЯрзНржпрж╛ржЧ ржирж╛ ржерж╛ржХрзЗ, рждржмрзЗ ржПрж░ ржорж╛ржи `null` ржжрж╛ржУред

    ржЯрзЗржХрзНрж╕ржЯ:
    ---
    {text}
    ---
    
    JSON ржЖржЙржЯржкрзБржЯ ржЙржжрж╛рж╣рж░ржг:
    [
      {{
        "question": "ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗрж░ рж░рж╛ржЬржзрж╛ржирзАрж░ ржирж╛ржо ржХрж┐?",
        "options": ["ржврж╛ржХрж╛", "ржЪржЯрзНржЯржЧрзНрж░рж╛ржо", "ржЦрзБрж▓ржирж╛", "рж░рж╛ржЬрж╛рж╣рзА"],
        "correct_option_index": 0,
        "explanation": "ржврж╛ржХрж╛ ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗрж░ рж░рж╛ржЬржзрж╛ржирзА ржУ ржмрзГрж╣рждрзНрждржо рж╢рж╣рж░ред",
        "suffix": "[MAT 23-24]"
      }},
      {{
        "question": "рж╕рзВрж░рзНржп ржХрзЛржи ржжрж┐ржХрзЗ ржУржарзЗ?",
        "options": ["ржЙрждрзНрждрж░", "ржжржХрзНрж╖рж┐ржг", "ржкрзВрж░рзНржм", "ржкрж╢рзНржЪрж┐ржо"],
        "correct_option_index": 2,
        "explanation": null,
        "suffix": null
      }}
    ]
    """
    try:
        response = ai_model.generate_content(prompt)
        if not response.parts:
            print(f"AI рж░рзЗрж╕ржкржирзНрж╕ ржмрзНрж▓ржХржбред ржХрж╛рж░ржг: {response.prompt_feedback}")
            return None
        json_data = json.loads(response.text)
        return json_data
    except Exception as e:
        print(f"AI ржмрж╛ JSON ржкрж╛рж░рзНрж╕рж┐ржВ-ржП ржЕржЬрж╛ржирж╛ рж╕ржорж╕рзНржпрж╛: {e}") 
        return None

# --- ржЯрзБрж▓ ржлрж╛ржВрж╢ржи: рж╕рзНржЯрзЗржЯ рж░рж┐рж╕рзЗржЯ ржХрж░рж╛рж░ ржЬржирзНржп ---
def clear_user_state(user_data: dict):
    """ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржмрж░рзНрждржорж╛ржи ржЕржмрж╕рзНржерж╛ рж░рж┐рж╕рзЗржЯ ржХрж░рзЗ, ржкрзЗржирзНржбрж┐ржВ ржХрзБржЗржЬ ржПржмржВ ржЯрж╛ржЗржорж╛рж░ ржорзБржЫрзЗ ржлрзЗрж▓рзЗред"""
    user_data['CONV_STATE'] = STATE_IDLE
    if 'pending_quiz_data' in user_data: del user_data['pending_quiz_data']
    job_to_remove: Job | None = user_data.get('buffer_job')
    if job_to_remove:
        job_to_remove.remove() # ржЯрж╛ржЗржорж╛рж░ржЯрж┐ ржмржирзНржз ржХрж░рж╛
        del user_data['buffer_job']
    if 'text_buffer' in user_data: del user_data['text_buffer']


# ---!!! /start ржХржорж╛ржирзНржб рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ (HTML ржлрж░ржорзНржпрж╛ржЯрзЗ ржлрж┐ржХрзНрж╕ ржХрж░рж╛) !!!---
async def start_command(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ржирждрзБржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ /start ржХржорж╛ржирзНржбрзЗ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржирж┐рж░рзНржжрзЗрж╢ржирж╛ ржжрзЗржЦрж╛рзЯред
    """
    clear_user_state(context.user_data) # рж╕рзНржЯрзЗржЯ рж░рж┐рж╕рзЗржЯ ржХрж░рж╛
    
    # --- HTML ржлрж░ржорзНржпрж╛ржЯрзЗ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ---
    instructions = """
ЁЯСЛ ржЖрж╕рж╕рж╛рж▓рж╛ржорзБ ржЖрж▓рж╛ржЗржХрзБржо! <b>[SOT] ржкрзЛрж▓ ржмржЯ-ржП ржЖржкржирж╛ржХрзЗ рж╕рзНржмрж╛ржЧрждржоред</b>

ржПржЗ ржмржЯржЯрж┐ ржЖржкржирж╛рж░ ржЯрзЗржХрзНрж╕ржЯ ржорзЗрж╕рзЗржЬржХрзЗ рж╕рзБржирзНржжрж░ ржХрзБржЗржЬ ржкрзЛрж▓рзЗ рж░рзВржкрж╛ржирзНрждрж░ ржХрж░рзЗ ржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

<b>ржмржЯ ржмрзНржпржмрж╣рж╛рж░рзЗрж░ рж╕ржорзНржкрзВрж░рзНржг ржирж┐рзЯржорж╛ржмрж▓рзА:</b>

<b>ржзрж╛ржк рзз: ржЯрж╛рж░рзНржЧрзЗржЯ ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ ржХрж░рж╛ (рж╢рзБржзрзБ ржкрзНрж░ржержоржмрж╛рж░)</b>
ржмржЯржХрзЗ ржмрж▓рзБржи ржХрзЛржи ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░рждрзЗ рж╣ржмрзЗред
тАв ржХржорж╛ржирзНржб ржжрж┐ржи: <code>/setchannel &lt;channel_id_or_@username&gt;</code>
тАв ржЙржжрж╛рж╣рж░ржг (ржкрзНрж░рж╛ржЗржнрзЗржЯ ржЪрзНржпрж╛ржирзЗрж▓): <code>/setchannel -100123456789</code>
тАв ржЙржжрж╛рж╣рж░ржг (ржкрж╛ржмрж▓рж┐ржХ ржЪрзНржпрж╛ржирзЗрж▓): <code>/setchannel @MyQuizChannel</code>
<i>(ржмржЯржХрзЗ ржЕржмрж╢рзНржпржЗ рж╕рзЗржЗ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржЕрзНржпрж╛ржбржорж┐ржи рж╣рждрзЗ рж╣ржмрзЗ ржПржмржВ ржкрзЛрж▓ ржкрзЛрж╕рзНржЯ ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржерж╛ржХрждрзЗ рж╣ржмрзЗ)</i>

<b>ржзрж╛ржк рзи: ржкрзНрж░рж╢рзНржи ржкрж╛ржарж╛ржирзЛ</b>
ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржи, ржЕржкрж╢ржи, рж╕ржарж┐ржХ ржЙрждрзНрждрж░, ржмрзНржпрж╛ржЦрзНржпрж╛ ржПржмржВ рж╕рж╛ржлрж┐ржХрзНрж╕ (ржЯрзНржпрж╛ржЧ) ржирж┐ржЪрзЗрж░ ржорждрзЛ рж╕рж╛ржЬрж┐рзЯрзЗ ржмржЯржХрзЗ ржЯрзЗржХрзНрж╕ржЯ ржорзЗрж╕рзЗржЬ ржХрж░рзБржи:

<pre>
ржкрзНрж░рж╢рзНржи рзз? [ржЯрзНржпрж╛ржЧ-рзз]
(ржХ) ржЕржкрж╢ржи рзз
(ржЦ) ржЕржкрж╢ржи рзи
(ржЧ) ржЕржкрж╢ржи рзй
рж╕ржарж┐ржХ ржЙрждрзНрждрж░: (ржХ)
ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЯрж┐ рж╣рж▓рзЛ ржмрзНржпрж╛ржЦрзНржпрж╛...

ржкрзНрж░рж╢рзНржи рзи? [ржЯрзНржпрж╛ржЧ-рзи]
(ржХ) ржЕржкрж╢ржи рзз
(ржЦ) ржЕржкрж╢ржи рзи
рж╕ржарж┐ржХ ржЙрждрзНрждрж░: (ржЦ)
</pre>
тАв <b>[ржЯрзНржпрж╛ржЧ] (ржРржЪрзНржЫрж┐ржХ):</b> ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╢рзНржирзЗрж░ рж╢рзЗрж╖рзЗ <code>[ржмрзНрж░рзНржпрж╛ржХрзЗржЯрзЗрж░ ржоржзрзНржпрзЗ]</code> ржЯрзНржпрж╛ржЧ ржжрж┐рж▓рзЗ, ржмржЯ рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯржнрж╛ржмрзЗ рж╕рзЗржЯрж┐ржХрзЗ ржкрзНрж░рж╢рзНржирзЗрж░ рж╢рзЗрж╖рзЗ ржпрзЛржЧ ржХрж░ржмрзЗ (ржпрзЗржоржи: <code>[MAT 23-24]</code>)ред
тАв <b>ржмрзНржпрж╛ржЦрзНржпрж╛ (ржРржЪрзНржЫрж┐ржХ):</b> "ржмрзНржпрж╛ржЦрзНржпрж╛:" рж▓рж┐ржЦрж▓рзЗ ржмржЯ рж╕рзЗржЯрж┐ ржкрзЛрж▓рзЗ ржпрзБржХрзНржд ржХрж░ржмрзЗред

<i>(<b>ржжрзНрж░рж╖рзНржЯржмрзНржп:</b> ржмржЯ рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯржнрж╛ржмрзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╢рзНржирзЗрж░ ржЖржЧрзЗ <b>[SOT]</b> ржпрзЛржЧ ржХрж░рзЗ ржжрзЗржмрзЗред)</i>

<b>ржзрж╛ржк рзй: рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛ (Intro Message) ржкрж╛ржарж╛ржирзЛ</b>
ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛ рж╕ржлрж▓ржнрж╛ржмрзЗ ржкрзНрж░рж╕рзЗрж╕ ржХрж░рж╛рж░ ржкрж░, ржмржЯ ржЖржкржирж╛ржХрзЗ ржПржХржЯрж┐ "рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛" ржкрж╛ржарж╛рждрзЗ ржмрж▓ржмрзЗред
тАв ржЖржкржирж┐ рждржЦржи ржХрзБржЗржЬрзЗрж░ рж╢рж┐рж░рзЛржирж╛ржо (ржпрзЗржоржи: "ржЖржЬржХрзЗрж░ рж░рж╕рж╛рзЯржи ржХрзБржЗржЬ") рж▓рж┐ржЦрзЗ ржкрж╛ржарж╛ржиред
тАв ржмржЯ рж╕рзЗржЗ рж╢рж┐рж░рзЛржирж╛ржоржЯрж┐ ржЖржЧрзЗ ржкрзЛрж╕рзНржЯ ржХрж░ржмрзЗ, рждрж╛рж░ржкрж░ ржкрзЛрж▓ржЧрзБрж▓рзЛ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ рж╢рзБрж░рзБ ржХрж░ржмрзЗред

<b>ржЕржирзНржпрж╛ржирзНржп ржХржорж╛ржирзНржб:</b>
тАв <code>/cancel</code> - ржпрзЗржХрзЛржирзЛ рж╕ржорзЯ ржХрзЛржирзЛ ржХрж╛ржЬ (ржпрзЗржоржи рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛рж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛) ржмрж╛рждрж┐рж▓ ржХрж░рждрзЗ ржПржЗ ржХржорж╛ржирзНржб ржжрж┐ржиред
тАв <code>/help</code> - ржХржорж╛ржирзНржбржЧрзБрж▓рзЛрж░ ржПржХржЯрж┐ рж╕ржВржХрзНрж╖рж┐ржкрзНржд рждрж╛рж▓рж┐ржХрж╛ ржжрзЗржЦрждрзЗ ржПржЗ ржХржорж╛ржирзНржб ржжрж┐ржиред
"""
    
    await update.message.reply_text(
        instructions,
        parse_mode=ParseMode.HTML # <--!!! HTML-ржП ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ !!!
    )

# ---!!! /help ржХржорж╛ржирзНржб рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ !!!---
async def help_command(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /help ржХржорж╛ржирзНржбрзЗ ржХржорж╛ржирзНржбржЧрзБрж▓рзЛрж░ ржПржХржЯрж┐ рж╕ржВржХрзНрж╖рж┐ржкрзНржд рждрж╛рж▓рж┐ржХрж╛ ржжрзЗржЦрж╛рзЯред
    """
    help_text = """
тД╣я╕П **[SOT] ржкрзЛрж▓ ржмржЯ - рж╣рзЗрж▓рзНржк ржорзЗржирзБ**

ржПржЦрж╛ржирзЗ ржмржЯрзЗрж░ ржкрзНрж░ржзрж╛ржи ржХржорж╛ржирзНржбржЧрзБрж▓рзЛ ржжрзЗржУрзЯрж╛ рж╣рж▓рзЛ:

* `/start` - ржмржЯ рж╕ржорзНржкрж░рзНржХрзЗ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржирж┐рж░рзНржжрзЗрж╢ржирж╛ ржУ рж╕ржорзНржкрзВрж░рзНржг ржЧрж╛ржЗржбрж▓рж╛ржЗржи ржжрзЗржЦрж╛рзЯред
* `/setchannel <ID>` - ржХрзЛржи ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж▓ ржкрзЛрж╕рзНржЯ ржХрж░рждрзЗ ржЪрж╛ржи рждрж╛ рж╕рзЗржЯ ржХрж░рзЗред (ржпрзЗржоржи: `/setchannel -100123...`)
* `/cancel` - ржХрзЛржирзЛ ржЪрж▓ржорж╛ржи ржХрж╛ржЬ (ржпрзЗржоржи: рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛рж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛) ржмрж╛рждрж┐рж▓ ржХрж░рзЗред
* `/help` - ржПржЗ рж╣рзЗрж▓рзНржк ржорзЗрж╕рзЗржЬржЯрж┐ ржжрзЗржЦрж╛рзЯред
"""
    await update.message.reply_text(
        help_text,
        parse_mode=ParseMode.MARKDOWN
    )
# ------------------------------------


# --- ржЯрж╛ржЗржорж╛рж░ рж╢рзЗрж╖ рж╣рж▓рзЗ ржПржЗ ржлрж╛ржВрж╢ржиржЯрж┐ рж░рж╛ржи рж╣ржмрзЗ (ржмрж╛ржлрж╛рж░рж┐ржВ ржПрж░ ржЬржирзНржп) ---
async def process_buffered_text(context: ContextTypes.DEFAULT_TYPE):
    """
    ржмрж╛ржлрж╛рж░рзЗ ржЬржорж╛ рж╣ржУрзЯрж╛ рж╕ржорзНржкрзВрж░рзНржг ржЯрзЗржХрзНрж╕ржЯржХрзЗ AI ржжрж┐рзЯрзЗ ржкрзНрж░рж╕рзЗрж╕ ржХрж░рзЗред
    """
    job_data = context.job.data
    chat_id = job_data['chat_id']
    user_id = job_data['user_id']
    
    # user_data JobQueue ржерзЗржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯ ржирж╛
    user_data = context.application.user_data[user_id] 
    ai_model = context.application.bot_data['ai_model'] # ржЕрзНржпрж╛ржкрж▓рж┐ржХрзЗрж╢ржи ржерзЗржХрзЗ ai_model рж▓рзЛржб ржХрж░рж╛

    target_channel = get_target_channel_from_db(user_id) # ржбрж╛ржЯрж╛ржмрзЗрж╕ ржерзЗржХрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржкрзЬрж╛
    if not target_channel:
        await context.bot.send_message(chat_id=chat_id, text="тЪая╕П ржЯрж╛рж░рзНржЧрзЗржЯ ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗред /setchannel ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред")
        clear_user_state(user_data)
        return

    full_text = "\n".join(user_data.get('text_buffer', []))
    
    # ржмрж╛ржлрж╛рж░ ржПржмржВ ржЬржм ржХрзНрж▓рж┐рзЯрж╛рж░ ржХрж░рж╛
    if 'buffer_job' in user_data: del user_data['buffer_job']
    if 'text_buffer' in user_data: del user_data['text_buffer']
        
    if not full_text:
        await context.bot.send_message(chat_id=chat_id, text="тЪая╕П ржЯрзЗржХрзНрж╕ржЯ ржЦрзБржБржЬрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
        clear_user_state(user_data)
        return

    await context.bot.send_message(chat_id=chat_id, text=f"рж╕ржорзНржкрзВрж░рзНржг ржЯрзЗржХрзНрж╕ржЯ ржкрзЗрзЯрзЗржЫрж┐ ({len(full_text)} ржЕржХрзНрж╖рж░)ред ржЬрзЗржорж┐ржирж┐ ржПржЖржЗ ржжрж┐рзЯрзЗ ржкрзНрж░рж╕рзЗрж╕ ржХрж░ржЫрж┐... ЁЯдЦ")
    
    questions_data = get_questions_from_ai(full_text, ai_model) # ai_model ржкрж╛рж╕ ржХрж░рж╛
    
    if not questions_data or not isinstance(questions_data, list) or len(questions_data) == 0:
        await context.bot.send_message(chat_id=chat_id, text="ржжрзБржГржЦрж┐ржд, AI ржкрзНрж░рж╢рзНржи рждрзИрж░рж┐ ржХрж░рждрзЗ ржмрзНржпрж░рзНрже рж╣рзЯрзЗржЫрзЗ ржмрж╛ ржХрзЛржирзЛ ржкрзНрж░рж╢рзНржи ржЦрзБржБржЬрзЗ ржкрж╛рзЯржирж┐ред")
        clear_user_state(user_data)
        return
    
    # ржкрзНрж░рж╢рзНржи рж╕ржлрж▓ рж╣рж▓рзЗ, рж╕рзЗржн ржХрж░рж╛ ржПржмржВ рж╕рзВржЪржирж╛рж░ ржЬржирзНржп ржмрж▓рж╛
    user_data['pending_quiz_data'] = questions_data
    user_data['CONV_STATE'] = STATE_AWAITING_INTRO 
    await context.bot.send_message(
        chat_id=chat_id, 
        text=f"тЬЕ {len(questions_data)} ржЯрж┐ ржкрзНрж░рж╢рзНржи рж╕ржлрж▓ржнрж╛ржмрзЗ ржкрзНрж░рж╕рзЗрж╕ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред\n\n"
             "тЮбя╕П **ржПржЦржи ржПржЗ ржХрзБржЗржЬрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛ (intro text) ржкрж╛ржарж╛ржиред**\n\n"
             "(ржЕржержмрж╛ /cancel рж▓рж┐ржЦрзЗ ржмрж╛рждрж┐рж▓ ржХрж░рзБржи)"
    )


# ---!!! ржорзВрж▓ ржЯрзЗржХрзНрж╕ржЯ ржорзЗрж╕рзЗржЬ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ (рж╕рзНржЯрзЗржЯ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ) !!!---
async def handle_text(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text
    chat_id = update.message.chat_id
    user = update.effective_user
    
    # ржЗржЙржЬрж╛рж░рзЗрж░ ржмрж░рзНрждржорж╛ржи ржЕржмрж╕рзНржерж╛ (state) ржЪрзЗржХ ржХрж░рж╛
    current_state = context.user_data.get('CONV_STATE', STATE_IDLE)
    
    # --- ржзрж╛ржк рзз: ржпржжрж┐ ржмржЯ рж╕рзВржЪржирж╛рж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ ---
    if current_state == STATE_AWAITING_INTRO:
        
        intro_text = user_message # ржПржЗ ржорзЗрж╕рзЗржЬржЯрж┐ржЗ рж╣рж▓рзЛ рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛
        target_channel = get_target_channel_from_db(user.id) # ржбрж╛ржЯрж╛ржмрзЗрж╕ ржерзЗржХрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржкрзЬрж╛
        questions_data = context.user_data.get('pending_quiz_data')
        
        if not target_channel or not questions_data:
            await context.bot.send_message(chat_id=chat_id, text="тЪая╕П ржПржХржЯрж┐ рждрзНрж░рзБржЯрж┐ рж╣рзЯрзЗржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ /cancel ржХрж░рзЗ ржЖржмрж╛рж░ рж╢рзБрж░рзБ ржХрж░рзБржиред")
            clear_user_state(context.user_data)
            return

        await context.bot.send_message(chat_id=chat_id, text=f" рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛ ржкрзЗрзЯрзЗржЫрж┐ред '{target_channel}'-ржП ржкрзЛрж╕рзНржЯ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
        count = 0
        errors = 0
        
        try:
            # --- ржкрзНрж░ржержорзЗ ржХрж╛рж╕рзНржЯржо рж╕рзВржЪржирж╛ ржмрж╛рж░рзНрждрж╛ржЯрж┐ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ ---
            await context.bot.send_message(chat_id=target_channel, text=intro_text)
            
            # --- рждрж╛рж░ржкрж░ ржкрзЛрж▓ржЧрзБрж▓рзЛ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ ---
            for poll_data in questions_data:
                try:
                    # ---!!! ржбрж╛ржЗржирж╛ржорж┐ржХ рж▓рж┐ржЧрзНржпрж╛рж╕рж┐ ржпрзЛржЧ ржХрж░рж╛ !!!---
                    original_question = poll_data['question']
                    dynamic_suffix = poll_data.get('suffix') # AI ржерзЗржХрзЗ ржкрж╛ржУрзЯрж╛ рж╕рж╛ржлрж┐ржХрзНрж╕ (null рж╣рждрзЗ ржкрж╛рж░рзЗ)
                    
                    static_prefix = "[SOT]" # <-- ржЖржкржирж╛рж░ рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯ ржкрзНрж░рж┐ржлрж┐ржХрзНрж╕
                    
                    # \u200B рж╣рж▓рзЛ ржПржХржЯрж┐ ржЬрж┐рж░рзЛ-ржЙржЗржбрже рж╕рзНржкрзЗрж╕ (рж╕рзБржирзНржжрж░ ржжрзЗржЦрж╛ржирзЛрж░ ржЬржирзНржп)
                    formatted_question = f"{static_prefix} \u200B {original_question}"
                    
                    # ржпржжрж┐ рж╕рж╛ржлрж┐ржХрзНрж╕ ржерж╛ржХрзЗ (null ржирж╛ рж╣рзЯ), рждржмрзЗржЗ рж╕рзЗржЯрж┐ ржпрзЛржЧ ржХрж░рж╛
                    if dynamic_suffix:
                        formatted_question = f"{formatted_question} \u200B {dynamic_suffix}"
                    
                    # -----------------------------------------------

                    # ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржкрзЛрж▓рзЗрж░ ржкрзНрж░рж╢рзНржирзЗрж░ ржЕржХрзНрж╖рж░ рж╕рзАржорж╛ ржЪрзЗржХ ржХрж░рж╛ (рзйрзжрзж ржЕржХрзНрж╖рж░)
                    if len(formatted_question) > 300:
                        # ржпржжрж┐ ржЦрзБржм рж▓ржорзНржмрж╛ рж╣рзЯ, рж▓рж┐ржЧрзНржпрж╛рж╕рж┐ ржЫрж╛рзЬрж╛ рж╢рзБржзрзБ ржкрзНрж░рж╢рзНржиржЯрж┐ ржкрж╛ржарж╛ржирзЛ
                        if len(original_question) > 300:
                            formatted_question = original_question[:300]
                        else:
                            formatted_question = original_question
                    # -----------------------------------------------

                    await context.bot.send_poll(
                        chat_id=target_channel,
                        question=formatted_question, # <-- ржПржЦрж╛ржирзЗ ржкрж░рж┐ржмрж░рзНрждрж┐ржд ржкрзНрж░рж╢рзНржиржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛
                        options=poll_data['options'],
                        type=telegram.Poll.QUIZ,
                        correct_option_id=poll_data['correct_option_index'],
                        explanation=poll_data.get('explanation') 
                    )
                    count += 1
                    await asyncio.sleep(1) # ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржорзЗрж░ рж░рзЗржЯ рж▓рж┐ржорж┐ржЯ ржПрзЬрж╛ржирзЛрж░ ржЬржирзНржп
                except Exception as e:
                    print(f"ржкрзЛрж▓ ржкрж╛ржарж╛рждрзЗ рж╕ржорж╕рзНржпрж╛ (ржЪрзНржпрж╛ржирзЗрж▓ {target_channel}): {e}")
                    errors += 1
        
        except Exception as e:
            # ржпржжрж┐ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржнрзБрж▓ рж╣рзЯ ржмрж╛ ржмржЯ ржЕрзНржпрж╛ржбржорж┐ржи ржирж╛ ржерж╛ржХрзЗ
            print(f"ржЪрзНржпрж╛ржирзЗрж▓ {target_channel}-ржП ржорзЗрж╕рзЗржЬ ржкрж╛ржарж╛ржирзЛ ржпрж╛рзЯржирж┐: {e}")
            await context.bot.send_message(chat_id=chat_id, text=f"тЪая╕П ржЪрзНржпрж╛ржирзЗрж▓ '{target_channel}'-ржП ржкрзЛрж╕рзНржЯ ржХрж░рждрзЗ ржорж╛рж░рж╛рждрзНржоржХ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ: {e}")
            clear_user_state(context.user_data)
            return

        # рж╕ржлрж▓ржнрж╛ржмрзЗ ржкрзЛрж╕рзНржЯ ржХрж░рж╛рж░ ржкрж░ рж╕рзНржЯрзЗржЯ рж░рж┐рж╕рзЗржЯ ржХрж░рж╛
        clear_user_state(context.user_data)
        feedback_message = f"рж╕ржлрж▓ржнрж╛ржмрзЗ ржЪрзНржпрж╛ржирзЗрж▓ '{target_channel}'-ржП {count} ржЯрж┐ ржкрзЛрж▓ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ!"
        if errors > 0: feedback_message += f"\n{errors} ржЯрж┐ ржкрзЛрж╕рзНржЯрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред"
        await context.bot.send_message(chat_id=chat_id, text=feedback_message)

    
    # --- ржзрж╛ржк рзи: ржпржжрж┐ ржмржЯ ржирждрзБржи ржкрзНрж░рж╢рзНржирзЗрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ (IDLE) (ржмрж╛ржлрж╛рж░рж┐ржВ рж▓ржЬрж┐ржХ) ---
    elif current_state == STATE_IDLE:
        
        target_channel = get_target_channel_from_db(user.id) # ржбрж╛ржЯрж╛ржмрзЗрж╕ ржерзЗржХрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржкрзЬрж╛
        if not target_channel:
            await context.bot.send_message(chat_id=chat_id, text="тЪая╕П ржЯрж╛рж░рзНржЧрзЗржЯ ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗред /setchannel ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред")
            return

        # --- ржмрж╛ржлрж╛рж░рж┐ржВ рж▓ржЬрж┐ржХ рж╢рзБрж░рзБ ---
        
        # ржпржжрж┐ ржХрзЛржирзЛ ржЯрж╛ржЗржорж╛рж░ ржЖржЧрзЗ ржерзЗржХрзЗржЗ ржЪрж╛рж▓рзБ ржерж╛ржХрзЗ (ржЕрж░рзНржерж╛рзО ржПржЯрж┐ ржПржХржЯрж┐ рж╕рзНржкрзНрж▓рж┐ржЯ ржорзЗрж╕рзЗржЬ)
        if 'buffer_job' in context.user_data:
            context.user_data['buffer_job'].remove() # ржкрзБрж░рж╛ржирзЛ ржЯрж╛ржЗржорж╛рж░ ржмрж╛рждрж┐рж▓
        
        # ржЯрзЗржХрзНрж╕ржЯ ржмрж╛ржлрж╛рж░рзЗ ржПржЗ ржорзЗрж╕рзЗржЬржЯрж┐ ржпрзЛржЧ ржХрж░рж╛
        if 'text_buffer' not in context.user_data:
            context.user_data['text_buffer'] = []
            # ржПржЯрж┐ржЗ ржкрзНрж░ржержо ржорзЗрж╕рзЗржЬ, рждрж╛ржЗ ржЗржЙржЬрж╛рж░ржХрзЗ ржЬрж╛ржирж╛ржирзЛ
            await context.bot.send_message(chat_id=chat_id, text="ржЯрзЗржХрзНрж╕ржЯ ржкрзЗрзЯрзЗржЫрж┐... (ржЖрж░ржУ ржЯрзЗржХрзНрж╕ржЯ ржПрж▓рзЗ рж╕рзЗржЧрзБрж▓рзЛрж░ ржЬржирзНржп рзй рж╕рзЗржХрзЗржирзНржб ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐)")
            
        context.user_data['text_buffer'].append(user_message)
        
        # ржПржХржЯрж┐ ржирждрзБржи ржЯрж╛ржЗржорж╛рж░ рж╕рзЗржЯ ржХрж░рж╛
        new_job = context.job_queue.run_once(
            process_buffered_text, 
            TEXT_BUFFER_DELAY, 
            data={'chat_id': chat_id, 'user_id': user.id},
            name=f"buffer-{user.id}"
        )
        context.user_data['buffer_job'] = new_job
        # --- ржмрж╛ржлрж╛рж░рж┐ржВ рж▓ржЬрж┐ржХ рж╢рзЗрж╖ ---
        

# ---!!! ржмржЯ ржЪрж╛рж▓рзБ ржХрж░рж╛рж░ ржорзЗржЗржи ржлрж╛ржВрж╢ржи (Race Condition ржлрж┐ржХрзНрж╕ржб) !!!---
def main():
    print("ржмржЯ ржЪрж╛рж▓рзБ рж╣ржЪрзНржЫрзЗ...")
    
    # --- ржнрзЗрж░рж┐рзЯрзЗржмрж▓ржЧрзБрж▓рзЛ ржПржЦржи main() ржПрж░ ржнрзЗрждрж░рзЗ рж▓рзЛржб рж╣ржЪрзНржЫрзЗ ---
    TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
    DATABASE_URL = os.environ.get("DATABASE_URL") 

    # --- ржнрзЗрж░рж┐рзЯрзЗржмрж▓ ржЪрзЗржХ ---
    if not TELEGRAM_BOT_TOKEN or not GEMINI_API_KEY or not DATABASE_URL:
        print("---!!! ERROR: ржЯрзЛржХрзЗржи ржмрж╛ ржПржкрж┐ржЖржЗ ржХрзА рж╕рзЗржЯ ржХрж░рж╛ рж╣ржпрж╝ржирж┐ !!!---")
        print("Render-ржПрж░ 'Environment' ржЯрзНржпрж╛ржмрзЗ ржнрзЗрж░рж┐рзЯрзЗржмрж▓ржЧрзБрж▓рзЛ ржЪрзЗржХ ржХрж░рзБржиред")
        return # ржмржЯ ржмржирзНржз ржХрж░рзЗ ржжрж╛ржУ

    print("ржЯрзЛржХрзЗржи ржПржмржВ ржХрзА рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓рзЛржб рж╣рзЯрзЗржЫрзЗред")

    # --- ржЬрзЗржорж┐ржирж┐ ржПржЖржЗ ржПржЦржи ржПржЦрж╛ржирзЗ ржХржиржлрж┐ржЧрж╛рж░ рж╣ржЪрзНржЫрзЗ ---
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        generation_config = genai.GenerationConfig(response_mime_type="application/json")
        ai_model = genai.GenerativeModel('gemini-flash-latest', generation_config=generation_config)
        print("Gemini AI рж╕ржлрж▓ржнрж╛ржмрзЗ ржХржиржлрж┐ржЧрж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ (JSON ржорзЛржбрзЗ)ред")
    except Exception as e:
        print(f"Gemini AI ржХржиржлрж┐ржЧрж╛рж░рзЗрж╢ржирзЗ рж╕ржорж╕рзНржпрж╛: {e}")
        return

    # --- ржбрж╛ржЯрж╛ржмрзЗрж╕ ржЪрж╛рж▓рзБ ржХрж░рж╛ ---
    init_db()

    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .build()
    )
    
    # --- ai_model ржХрзЗ ржЕрзНржпрж╛ржкрзНрж▓рж┐ржХрзЗрж╢ржи ржХржиржЯрзЗржХрзНрж╕ржЯрзЗ рж╕рзЗржн ржХрж░рж╛ ---
    # ржпрж╛рждрзЗ process_buffered_text ржлрж╛ржВрж╢ржиржЯрж┐ ржПржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗ
    application.bot_data['ai_model'] = ai_model

    # --- рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ рж╕рзЗржХрж╢ржи ---
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("setchannel", set_channel))
    application.add_handler(CommandHandler("cancel", cancel_quiz))
    application.add_handler(CommandHandler("help", help_command)) # <-- /help ржХржорж╛ржирзНржб
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    # ------------------------------------

    print("ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯ ржкрзЛрж▓рж┐ржВ рж╢рзБрж░рзБ ржХрж░ржЫрзЗ...")
    
    # Flask рж╕рж╛рж░рзНржнрж╛рж░ ржЪрж╛рж▓рзБ ржХрж░рж╛ (ржмржЯржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп)
    web_thread = threading.Thread(target=run_web_server)
    web_thread.daemon = True
    web_thread.start()
    print("ржУрзЯрзЗржм рж╕рж╛рж░рзНржнрж╛рж░ ржЪрж╛рж▓рзБ рж╣рзЯрзЗржЫрзЗ (ржмржЯржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп)ред")
    
    application.run_polling()

if __name__ == "__main__":
    main()