
import telegram
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes,
)
from telegram.ext._jobqueue import Job
import google.generativeai as genai
import json
import asyncio
import os
import psycopg2
from urllib.parse import urlparse
from flask import Flask
import threading

# -----------------------------------------------------------------
# --- ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡¶æ ‡¶ï‡ßÄ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶∞ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ ---
# --- ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ñ‡¶® main() ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡ßá‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡¶¨‡ßá ---
# -----------------------------------------------------------------

# conversation-‡¶è‡¶∞ ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ (state)
STATE_IDLE, STATE_AWAITING_INTRO = range(2)
TEXT_BUFFER_DELAY = 3  # ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°

# --- Flask ‡¶ì‡ßü‡ßá‡¶¨ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ (‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á) ---
app = Flask(__name__)
@app.route('/')
def home():
    return "I am alive and polling!"

def run_web_server():
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)

# --- ‡¶®‡¶§‡ßÅ‡¶® ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®: ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶® (‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶°) ---
def get_db_connection():
    """Render-‡¶è‡¶∞ DATABASE_URL ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§"""
    try:
        # --- ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®: ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤‡¶ü‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶™‡ßú‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá ---
        db_url = os.environ.get("DATABASE_URL")
        if not db_url:
            print("‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶®‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: DATABASE_URL ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§")
            return None
        conn = psycopg2.connect(db_url)
        return conn
    except Exception as e:
        print(f"‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶®‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        return None

# --- (init_db, get_target_channel..., save_target_channel... ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶§‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á) ---
def init_db():
    conn = get_db_connection()
    if conn is None:
        print("‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶á‡¶®‡¶ø‡¶∂‡¶ø‡ßü‡¶æ‡¶≤‡¶æ‡¶á‡¶ú ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ‡•§")
        return
    try:
        with conn.cursor() as cur:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS user_settings (
                    user_id BIGINT PRIMARY KEY,
                    target_channel TEXT
                );
            """)
            conn.commit()
        print("‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤ (user_settings) ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡ßá‡¶ï/‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
    except Exception as e:
        print(f"‡¶ü‡ßá‡¶¨‡¶ø‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
    finally:
        conn.close()

def get_target_channel_from_db(user_id: int) -> str | None:
    conn = get_db_connection()
    if conn is None: return None
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT target_channel FROM user_settings WHERE user_id = %s", (user_id,))
            result = cur.fetchone()
            if result:
                return result[0]
            return None
    except Exception as e:
        print(f"‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶™‡ßú‡¶æ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        return None
    finally:
        conn.close()

def save_target_channel_to_db(user_id: int, target_channel: str):
    conn = get_db_connection()
    if conn is None: return
    try:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO user_settings (user_id, target_channel)
                VALUES (%s, %s)
                ON CONFLICT (user_id) DO UPDATE SET target_channel = EXCLUDED.target_channel;
            """, (user_id, target_channel))
            conn.commit()
    except Exception as e:
        print(f"‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
    finally:
        conn.close()


# --- ‡¶ú‡ßá‡¶Æ‡¶ø‡¶®‡¶ø ‡¶è‡¶Ü‡¶á ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ó‡ßç‡¶≤‡ßã‡¶¨‡¶æ‡¶≤ ‡¶∏‡ßç‡¶ï‡ßã‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶∞‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá ---

# AI ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® (‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á)
def get_questions_from_ai(text, ai_model): # <-- ‡¶®‡¶§‡ßÅ‡¶®: ai_model ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
    prompt = f"""
    ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶è‡¶ï‡¶ú‡¶® ‡¶¶‡¶ï‡ßç‡¶∑ ‡¶ü‡ßá‡¶≤‡¶ø‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶¨‡¶ü‡•§ ... (‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶™‡ßç‡¶∞‡¶Æ‡ßç‡¶™‡¶ü ‡¶è‡¶ñ‡¶æ‡¶®‡ßá) ...
    ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü:
    ---
    {text}
    ---
    """
    try:
        response = ai_model.generate_content(prompt)
        if not response.parts:
            print(f"AI ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶¨‡ßç‡¶≤‡¶ï‡¶°‡•§ ‡¶ï‡¶æ‡¶∞‡¶£: {response.prompt_feedback}")
            return None
        json_data = json.loads(response.text)
        return json_data
    except Exception as e:
        print(f"AI ‡¶¨‡¶æ JSON ‡¶™‡¶æ‡¶∞‡ßç‡¶∏‡¶ø‡¶Ç-‡¶è ‡¶Ö‡¶ú‡¶æ‡¶®‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}") 
        return None

# (clear_user_state, start_command, set_channel, cancel_quiz ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶§‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á)
def clear_user_state(user_data: dict):
    user_data['CONV_STATE'] = STATE_IDLE
    if 'pending_quiz_data' in user_data: del user_data['pending_quiz_data']
    job_to_remove: Job | None = user_data.get('buffer_job')
    if job_to_remove:
        job_to_remove.remove()
        del user_data['buffer_job']
    if 'text_buffer' in user_data: del user_data['text_buffer']

async def start_command(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    clear_user_state(context.user_data)
    await update.message.reply_text(
        "‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ!\n"
        "‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá, ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá /setchannel ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡¶ø‡ßü‡ßá ‡¶ü‡¶æ‡¶∞‡ßç‡¶ó‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
    )

async def set_channel(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    clear_user_state(context.user_data)
    if not context.args:
        await update.message.reply_text("‚ö†Ô∏è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞: /setchannel <channel_id_or_@username>")
        return
    target_channel = context.args[0]
    save_target_channel_to_db(user_id, target_channel)
    await update.message.reply_text(
        f"‚úÖ ‡¶ü‡¶æ‡¶∞‡ßç‡¶ó‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá: {target_channel}\n"
        "(‡¶è‡¶á ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶ü‡¶ø ‡¶è‡¶ñ‡¶® ‡¶∏‡ßç‡¶•‡¶æ‡ßü‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡ßá‡¶≠ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)"
    )

async def cancel_quiz(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    clear_user_state(context.user_data)
    await update.message.reply_text("‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶ï‡¶æ‡¶ú‡¶ü‡¶ø ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡•§")


# ‡¶ü‡¶æ‡¶á‡¶Æ‡¶æ‡¶∞ ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá ‡¶è‡¶á ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ü‡¶ø ‡¶∞‡¶æ‡¶® ‡¶π‡¶¨‡ßá (‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶°)
async def process_buffered_text(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    chat_id = job_data['chat_id']
    user_id = job_data['user_id']
    user_data = context.application.user_data[user_id] 
    ai_model = context.application.bot_data['ai_model'] # <-- ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶•‡ßá‡¶ï‡ßá ai_model ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ

    target_channel = get_target_channel_from_db(user_id)
    if not target_channel:
        await context.bot.send_message(chat_id=chat_id, text="‚ö†Ô∏è ‡¶ü‡¶æ‡¶∞‡ßç‡¶ó‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§ /setchannel ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        clear_user_state(user_data)
        return

    full_text = "\n".join(user_data.get('text_buffer', []))
    if 'buffer_job' in user_data: del user_data['buffer_job']
    if 'text_buffer' in user_data: del user_data['text_buffer']
    if not full_text:
        await context.bot.send_message(chat_id=chat_id, text="‚ö†Ô∏è ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§")
        clear_user_state(user_data)
        return

    await context.bot.send_message(chat_id=chat_id, text=f"‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶™‡ßá‡ßü‡ßá‡¶õ‡¶ø ({len(full_text)} ‡¶Ö‡¶ï‡ßç‡¶∑‡¶∞)‡•§ ‡¶ú‡ßá‡¶Æ‡¶ø‡¶®‡¶ø ‡¶è‡¶Ü‡¶á ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶õ‡¶ø... ü§ñ")
    
    questions_data = get_questions_from_ai(full_text, ai_model) # <-- ai_model ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ
    
    if not questions_data or not isinstance(questions_data, list) or len(questions_data) == 0:
        await context.bot.send_message(chat_id=chat_id, text="‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, AI ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶¨‡¶æ ‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡ßü‡¶®‡¶ø‡•§")
        clear_user_state(user_data)
        return
    
    user_data['pending_quiz_data'] = questions_data
    user_data['CONV_STATE'] = STATE_AWAITING_INTRO 
    await context.bot.send_message(
        chat_id=chat_id, 
        text=f"‚úÖ {len(questions_data)} ‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§\n\n"
             "‚û°Ô∏è **‡¶è‡¶ñ‡¶® ‡¶è‡¶á ‡¶ï‡ßÅ‡¶á‡¶ú‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßÇ‡¶ö‡¶®‡¶æ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ (intro text) ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§**\n\n"
             "(‡¶Ö‡¶•‡¶¨‡¶æ /cancel ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®)"
    )


# ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ (‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶°)
async def handle_text(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text
    chat_id = update.message.chat_id
    user = update.effective_user
    current_state = context.user_data.get('CONV_STATE', STATE_IDLE)
    
    if current_state == STATE_AWAITING_INTRO:
        intro_text = user_message
        target_channel = get_target_channel_from_db(user.id)
        questions_data = context.user_data.get('pending_quiz_data')
        if not target_channel or not questions_data:
            await context.bot.send_message(chat_id=chat_id, text="‚ö†Ô∏è ‡¶è‡¶ï‡¶ü‡¶ø ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá /cancel ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
            clear_user_state(context.user_data)
            return
        await context.bot.send_message(chat_id=chat_id, text=f" ‡¶∏‡ßÇ‡¶ö‡¶®‡¶æ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡ßá‡ßü‡ßá‡¶õ‡¶ø‡•§ '{target_channel}'-‡¶è ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
        count = 0
        errors = 0
        try:
            await context.bot.send_message(chat_id=target_channel, text=intro_text)
            for poll_data in questions_data:
                try:
                    await context.bot.send_poll(
                        chat_id=target_channel,
                        question=poll_data['question'],
                        options=poll_data['options'],
                        type=telegram.Poll.QUIZ,
                        correct_option_id=poll_data['correct_option_index'],
                        explanation=poll_data.get('explanation') 
                    )
                    count += 1
                    await asyncio.sleep(1) 
                except Exception as e:
                    print(f"‡¶™‡ßã‡¶≤ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ (‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ {target_channel}): {e}")
                    errors += 1
        except Exception as e:
            print(f"‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ {target_channel}-‡¶è ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø: {e}")
            await context.bot.send_message(chat_id=chat_id, text=f"‚ö†Ô∏è ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ '{target_channel}'-‡¶è ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Æ‡¶æ‡¶∞‡¶æ‡¶§‡ßç‡¶Æ‡¶ï ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá: {e}")
            clear_user_state(context.user_data)
            return
        clear_user_state(context.user_data)
        feedback_message = f"‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ '{target_channel}'-‡¶è {count} ‡¶ü‡¶ø ‡¶™‡ßã‡¶≤ ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!"
        if errors > 0: feedback_message += f"\n{errors} ‡¶ü‡¶ø ‡¶™‡ßã‡¶∏‡ßç‡¶ü‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§"
        await context.bot.send_message(chat_id=chat_id, text=feedback_message)

    elif current_state == STATE_IDLE:
        target_channel = get_target_channel_from_db(user.id)
        if not target_channel:
            await context.bot.send_message(chat_id=chat_id, text="‚ö†Ô∏è ‡¶ü‡¶æ‡¶∞‡ßç‡¶ó‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§ /setchannel ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
            return
        if 'text_buffer' not in context.user_data:
            context.user_data['text_buffer'] = []
            await context.bot.send_message(chat_id=chat_id, text="‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶™‡ßá‡ßü‡ßá‡¶õ‡¶ø... (‡¶Ü‡¶∞‡¶ì ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶è‡¶≤‡ßá ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡ß© ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶õ‡¶ø)")
        if 'buffer_job' in context.user_data:
            context.user_data['buffer_job'].remove()
        context.user_data['text_buffer'].append(user_message)
        new_job = context.job_queue.run_once(
            process_buffered_text, 
            TEXT_BUFFER_DELAY, 
            data={'chat_id': chat_id, 'user_id': user.id},
            name=f"buffer-{user.id}"
        )
        context.user_data['buffer_job'] = new_job

# --- ‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡ßá‡¶á‡¶® ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® (‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶°) ---
def main():
    print("‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
    
    # ---!!! ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®: ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ñ‡¶® ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá !!!---
    # -----------------------------------------------------------------
# --- ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßÄ ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂ ‡¶•‡ßá‡¶ï‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡¶¨‡ßá ---
    TELEGRAM_BOT_TOKEN = os.environ.get("T8433405847:AAFwxcEPofbRkZ8QLRF8SpLn4hbF-pPluG8")
    GEMINI_API_KEY = os.environ.get("AIzaSyAVwCdnIDqK7bOwWbvSBK_UJCf6Ui3jA6Q")
    DATABASE_URL = os.environ.get("postgresql://poll_bot_db_user:dYb9wICOkT6ulSFLwK2AWSDBTNhQOdgu@dpg-d3trgpqli9vc73bkq9pg-a/poll_bot_db") # ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ init_db() ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø

    # --- ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤ ‡¶ö‡ßá‡¶ï ---
    if not TELEGRAM_BOT_TOKEN or not GEMINI_API_KEY or not DATABASE_URL:
        print("---!!! ERROR: ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡¶æ ‡¶è‡¶™‡¶ø‡¶Ü‡¶á ‡¶ï‡ßÄ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡¶®‡¶ø !!!---")
        print("Render-‡¶è‡¶∞ 'Environment' ‡¶ü‡ßç‡¶Ø‡¶æ‡¶¨‡ßá ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return # ‡¶¨‡¶ü ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßá ‡¶¶‡¶æ‡¶ì

    print("‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßÄ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")

    # --- ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®: ‡¶ú‡ßá‡¶Æ‡¶ø‡¶®‡¶ø ‡¶è‡¶Ü‡¶á ‡¶è‡¶ñ‡¶® ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶π‡¶ö‡ßç‡¶õ‡ßá ---
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        generation_config = genai.GenerationConfig(response_mime_type="application/json")
        ai_model = genai.GenerativeModel('gemini-flash-latest', generation_config=generation_config)
        print("Gemini AI ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá (JSON ‡¶Æ‡ßã‡¶°‡ßá)‡•§")
    except Exception as e:
        print(f"Gemini AI ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        return

    # --- ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ---
    init_db()

    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .build()
    )
    
    # --- ‡¶®‡¶§‡ßÅ‡¶®: ai_model ‡¶ï‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶ï‡¶®‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü‡ßá ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ---
    # ‡¶Ø‡¶æ‡¶§‡ßá process_buffered_text ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ü‡¶ø ‡¶è‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
    application.bot_data['ai_model'] = ai_model

    # ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ (‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á)
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("setchannel", set_channel))
    application.add_handler(CommandHandler("cancel", cancel_quiz))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    print("‡¶ü‡ßá‡¶≤‡¶ø‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶¨‡¶ü ‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶õ‡ßá...")
    
    # Flask ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ (‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡ßá‡¶á)
    web_thread = threading.Thread(target=run_web_server)
    web_thread.daemon = True
    web_thread.start()
    print("‡¶ì‡ßü‡ßá‡¶¨ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡ßü‡ßá‡¶õ‡ßá (‡¶¨‡¶ü‡¶ï‡ßá ‡¶ú‡¶æ‡¶ó‡¶ø‡ßü‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)‡•§")
    
    application.run_polling()

if __name__ == "__main__":
    main()